<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>å›³å½¢æ¤œå‡ºã‚µã‚¤ãƒˆ (GitHub Pages / OpenCV.js)</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; margin: 24px; }
    h1 { font-size: 1.8rem; margin: 0 0 .25rem; }
    .card { max-width: 980px; border: 1px solid #d0d0d0; border-radius: 16px; padding: 16px; box-shadow: 0 4px 20px rgba(0,0,0,.06); }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    label.button { display:inline-flex; align-items:center; gap:.5rem; background:#222; color:#fff; padding:.6rem 1rem; border-radius:999px; cursor:pointer; }
    input[type=file]{ display:none; }
    canvas { max-width: 100%; height: auto; border-radius: 10px; }
    .counts { font-weight: 600; margin-top: 8px; }
    .muted { opacity: .75; font-size: .9rem; }
    #cv-status { font-weight: 700; margin: .25rem 0 .75rem; }
  </style>
</head>
<body>
  <div class="card">
    <h1>ğŸ”µ å›³å½¢æ¤œå‡ºã‚µã‚¤ãƒˆï¼ˆOpenCV.js ç‰ˆï¼‰</h1>
    <p class="muted">ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã¨ã€<b>ä¸¸ãƒ»ä¸‰è§’ãƒ»å››è§’</b> ã‚’ãƒ–ãƒ©ã‚¦ã‚¶å†…ã ã‘ã§æ¤œå‡ºã—ã¾ã™ï¼ˆæ­£æ–¹å½¢/é•·æ–¹å½¢ã®åŒºåˆ¥ãªã—ï¼‰ã€‚ãƒ‡ãƒ¼ã‚¿ã¯ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ã•ã‚Œã¾ã›ã‚“ã€‚</p>

    <!-- âœ… OpenCV.js ã®èª­ã¿è¾¼ã¿çŠ¶æ…‹ã‚’è¡¨ç¤º -->
    <p id="cv-status" style="color:gray;">â³ OpenCV.js ã®èª­ã¿è¾¼ã¿ã‚’å¾…æ©Ÿä¸­...</p>

    <div class="row" style="margin:.5rem 0 1rem;">
      <label class="button">ğŸ“¤ ç”»åƒã‚’é¸ã¶ <input id="file" type="file" accept="image/*" disabled /></label>
      <span class="muted">â€» èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«ãƒœã‚¿ãƒ³ãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã™</span>
    </div>

    <canvas id="canvas"></canvas>
    <div id="counts" class="counts">æœªå‡¦ç†</div>
  </div>

  <!-- ===== OpenCV.js ãƒ­ãƒ¼ãƒ€ï¼ˆè¤‡æ•°CDNã‚’é †ç•ªã«ãƒˆãƒ©ã‚¤ï¼‰ ===== -->
  <script>
    // èª­ã¿è¾¼ã¿å€™è£œï¼ˆä¸Šã‹ã‚‰é †ã«è©¦è¡Œï¼‰
    const OPENCV_URLS = [
      "https://docs.opencv.org/4.9.0/opencv.js",
      "https://unpkg.com/@techstark/opencv-js@4.9.0-1/dist/opencv.js",
      "https://cdn.jsdelivr.net/gh/opencv/opencv@4.x/dist/opencv.js"
    ];

    const statusEl = document.getElementById('cv-status');
    const fileInput = document.getElementById('file');

    let cvReady = false;

    function onCvReady() {
      // ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒå–ã‚Œã¦ã‚‚WASMã®åˆæœŸåŒ–å¾…ã¡ãŒå¿…è¦ãªã“ã¨ãŒã‚ã‚‹
      if (window.cv) {
        if (cv.getBuildInformation) {
          cvReady = true;
          statusEl.textContent = "âœ… OpenCV.js èª­ã¿è¾¼ã¿å®Œäº†ï¼ˆå³æ™‚ï¼‰";
          statusEl.style.color = "green";
          fileInput.disabled = false;
        } else {
          cv['onRuntimeInitialized'] = () => {
            cvReady = true;
            statusEl.textContent = "âœ… OpenCV.js åˆæœŸåŒ–å®Œäº†";
            statusEl.style.color = "green";
            fileInput.disabled = false;
          };
        }
      } else {
        statusEl.textContent = "âŒ OpenCV.js ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“";
        statusEl.style.color = "red";
      }
    }

    function loadOpenCvSequential(urls) {
      if (!urls.length) {
        statusEl.textContent = "âŒ OpenCV.js ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆå…¨CDN NGï¼‰";
        statusEl.style.color = "red";
        return;
      }
      const url = urls[0];
      statusEl.textContent = `â³ OpenCV.js ã‚’èª­ã¿è¾¼ã¿ä¸­â€¦ ${url}`;
      statusEl.style.color = "gray";

      const s = document.createElement("script");
      s.async = true;
      s.src = url;
      s.onload = onCvReady;
      s.onerror = () => {
        // æ¬¡ã®å€™è£œã¸
        loadOpenCvSequential(urls.slice(1));
      };
      document.body.appendChild(s);
    }

    // èµ·å‹•æ™‚ã«èª­ã¿è¾¼ã¿é–‹å§‹
    loadOpenCvSequential(OPENCV_URLS);
  </script>

  <!-- ===== å›³å½¢æ¤œå‡ºã®æœ¬ä½“ ===== -->
  <script>
    // èª¿æ•´ç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    const MIN_AREA = 500;       // å°ã•ã„ã‚´ãƒŸã‚’é™¤å»ï¼ˆpx^2ï¼‰
    const APPROX_COEF = 0.02;   // å¤šè§’å½¢è¿‘ä¼¼ä¿‚æ•°ï¼ˆå°ã•ã„ã»ã©é ‚ç‚¹ãŒå¢—ãˆã‚„ã™ã„ï¼‰
    const CIRCLE_THRESH = 0.80; // å††åº¦ã—ãã„å€¤ï¼ˆé«˜ã„ã»ã©çœŸå††ã®ã¿ã‚’ä¸¸æ‰±ã„ï¼‰

    const canvas = document.getElementById('canvas');
    const countsEl = document.getElementById('counts');

    // ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ HTMLImageElement ã‚’è¿”ã™
    function loadImage(file) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
      });
    }

    function classifyShape(cnt) {
      const area = cv.contourArea(cnt);
      if (area < MIN_AREA) return null;
      const peri = cv.arcLength(cnt, true);
      const approx = new cv.Mat();
      cv.approxPolyDP(cnt, approx, APPROX_COEF * peri, true);
      const v = approx.rows;
      approx.delete();
      if (v === 3) return "triangle";
      if (v === 4) return "square"; // æ­£æ–¹å½¢/é•·æ–¹å½¢ã®åŒºåˆ¥ãªã—
      const circularity = 4 * Math.PI * area / (peri * peri + 1e-6);
      if (circularity >= CIRCLE_THRESH) return "circle";
      return null;
    }

    async function handleFile(e) {
      const file = e.target.files?.[0];
      if (!file) return;
      if (!cvReady) {
        alert("OpenCV.js ã®æº–å‚™ä¸­ã§ã™ã€‚æ•°ç§’å¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚");
        return;
      }

      // ç”»åƒã‚’Canvasã¸æç”»
      const imgEl = await loadImage(file);
      const w = imgEl.naturalWidth, h = imgEl.naturalHeight;
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(imgEl, 0, 0, w, h);

      // Canvas â†’ Mat
      let src = cv.imread(canvas);
      let gray = new cv.Mat(), blur = new cv.Mat(), bw = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
      cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0, 0, cv.BORDER_DEFAULT);
      cv.threshold(blur, bw, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

      // è¼ªéƒ­æŠ½å‡º
      let contours = new cv.MatVector(), hierarchy = new cv.Mat();
      cv.findContours(bw, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      // å¯è¦–åŒ–
      let vis = src.clone();
      const green = new cv.Scalar(0,200,0,255);
      const count = { circle:0, triangle:0, square:0 };

      for (let i = 0; i < contours.size(); i++) {
        const cnt = contours.get(i);
        const label = classifyShape(cnt);
        if (!label) { cnt.delete(); continue; }
        count[label]++;

        const rect = cv.boundingRect(cnt);
        cv.rectangle(
          vis,
          new cv.Point(rect.x, rect.y),
          new cv.Point(rect.x + rect.width, rect.y + rect.height),
          green, 2
        );
        cv.putText(
          vis, label,
          new cv.Point(rect.x, Math.max(0, rect.y - 6)),
          cv.FONT_HERSHEY_SIMPLEX, 0.7, green, 2
        );
        cnt.delete();
      }

      // æç”»ã¨ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤º
      cv.imshow(canvas, vis);
      countsEl.textContent = `ğŸ”µ ä¸¸: ${count.circle}ã€€ğŸŸ© å››è§’: ${count.square}ã€€ğŸ”º ä¸‰è§’: ${count.triangle}`;

      // å¾Œç‰‡ä»˜ã‘ï¼ˆãƒ¡ãƒ¢ãƒªè§£æ”¾ï¼‰
      src.delete(); gray.delete(); blur.delete(); bw.delete();
      contours.delete(); hierarchy.delete(); vis.delete();
    }

    fileInput.addEventListener('change', handleFile);
  </script>
</body>
</html>
